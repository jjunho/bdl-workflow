import argparse
import os
import sys
import yaml
import re
import subprocess
import shutil
from datetime import datetime
from pathlib import Path

PROMPTS = [
    "arquivista.prompt.md",
    "construtor.prompt.md",
    "critico.prompt.md",
    "editor.prompt.md",
    "escritor.prompt.md",
    "guardiao_coesao.prompt.md",
    "guardiao_estilo.prompt.md",
    "workflow.md",
]


def find_project_root():
    """Encontra a raiz do projeto BDL procurando por BDL.yaml"""
    current = Path.cwd()
    for parent in [current] + list(current.parents):
        if (parent / "BDL.yaml").exists():
            return parent
    return None


def get_project_config(project_root=None):
    """Carrega configura√ß√£o do projeto do BDL.yaml"""
    if project_root is None:
        project_root = find_project_root()

    if project_root is None:
        return None

    config_path = project_root / "BDL.yaml"
    try:
        with open(config_path, "r", encoding="utf-8") as f:
            return yaml.safe_load(f)
    except Exception:
        return None


def validate_dependencies():
    """Valida se depend√™ncias externas est√£o dispon√≠veis"""
    deps = {}

    # Verifica LaTeX (para PDF)
    try:
        result = subprocess.run(
            ["pdflatex", "--version"], capture_output=True, text=True, timeout=5
        )
        deps["latex"] = result.returncode == 0
    except (subprocess.TimeoutExpired, FileNotFoundError):
        deps["latex"] = False

    # Verifica pandoc (para EPUB/HTML)
    try:
        result = subprocess.run(
            ["pandoc", "--version"], capture_output=True, text=True, timeout=5
        )
        deps["pandoc"] = result.returncode == 0
    except (subprocess.TimeoutExpired, FileNotFoundError):
        deps["pandoc"] = False

    return deps


def count_words_in_file(filepath):
    """Conta palavras em um arquivo markdown"""
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            content = f.read()
        # Remove markdown syntax e conta palavras
        text = re.sub(r"[#*`_\[\]()]", "", content)
        words = len(text.split())
        return words
    except Exception:
        return 0


def criar_estrutura_livro(nome, title, author):
    # Cria a estrutura sempre dentro de BDL/ na raiz
    try:
        base = os.path.join(nome)
        os.makedirs(os.path.join(base, ".github", "prompts"))
        for prompt in PROMPTS:
            open(os.path.join(base, ".github", "prompts", prompt), "w").close()
        open(os.path.join(base, ".gitignore"), "w").close()
        # BDL.yaml
        bdl_yaml = {
            "title": title or "",
            "author": author or "",
            "version": "0.1.0",
            "created_at": datetime.now().strftime("%Y-%m-%d"),
        }
        with open(os.path.join(base, "BDL.yaml"), "w", encoding="utf-8") as f:
            yaml.dump(bdl_yaml, f, allow_unicode=True)
        print(f"‚úÖ Projeto '{nome}' criado com sucesso.")
    except Exception as e:
        print(f"Erro: n√£o foi poss√≠vel criar diret√≥rio. {e}")
        sys.exit(1)


def init_cmd(args):
    nome = args.nome
    title = args.title
    author = args.author
    if os.path.exists(nome):
        print(f"Erro: diret√≥rio '{nome}' j√° existe.")
        sys.exit(1)
    criar_estrutura_livro(nome, title, author)


def stats_cmd(args):
    # Busca pela raiz do projeto
    project_root = find_project_root()
    if project_root is None:
        print("Erro: Projeto BDL n√£o encontrado. Execute 'bdl init' primeiro.")
        sys.exit(1)

    config = get_project_config(project_root)
    if config is None:
        print("Erro: N√£o foi poss√≠vel carregar BDL.yaml.")
        sys.exit(1)

    # Busca cap√≠tulos em v√°rias localiza√ß√µes poss√≠veis
    capitulo_dirs = [
        project_root / "capitulos" / "finalizados",
        project_root / "capitulos" / "ia",
        project_root / "capitulos" / "rascunhos",
        project_root / "capitulos",
    ]

    all_chapters = []
    for cap_dir in capitulo_dirs:
        if cap_dir.exists():
            for f in cap_dir.glob("*.md"):
                if "capitulo" in f.name.lower() or f.name.lower().startswith("cap"):
                    all_chapters.append(f)

    if not all_chapters:
        print("üìä Estat√≠sticas do Projeto")
        print("=" * 40)
        print(f"üìñ T√≠tulo: {config.get('title', 'N√£o definido')}")
        print(f"‚úçÔ∏è  Autor: {config.get('author', 'N√£o definido')}")
        print(f"üìÖ Criado: {config.get('created_at', 'N/A')}")
        print("‚ö†Ô∏è  Aviso: nenhum cap√≠tulo encontrado.")
        return

    # Calcula estat√≠sticas
    total_words = 0
    chapter_stats = []

    for chapter_path in all_chapters:
        words = count_words_in_file(chapter_path)
        total_words += words

        # Determina status baseado no diret√≥rio
        if "finalizados" in str(chapter_path):
            status = "‚úÖ Finalizado"
        elif "ia" in str(chapter_path):
            status = "ü§ñ Em revis√£o IA"
        elif "rascunhos" in str(chapter_path):
            status = "üìù Rascunho"
        else:
            status = "üìÑ Em progresso"

        chapter_stats.append(
            {
                "name": chapter_path.name,
                "words": words,
                "status": status,
                "path": chapter_path,
            }
        )

    # Ordena cap√≠tulos por nome
    chapter_stats.sort(key=lambda x: x["name"])

    # Exibe estat√≠sticas
    print("üìä Estat√≠sticas do Projeto")
    print("=" * 40)
    print(f"üìñ T√≠tulo: {config.get('title', 'N√£o definido')}")
    print(f"‚úçÔ∏è  Autor: {config.get('author', 'N√£o definido')}")
    print(f"üìÖ Criado: {config.get('created_at', 'N/A')}")
    print(f"üî¢ Total de cap√≠tulos: {len(all_chapters)}")
    print(f"üìù Palavras totais: {total_words:,}")

    if total_words > 0:
        avg_words = total_words // len(all_chapters)
        print(f"üìä M√©dia por cap√≠tulo: {avg_words:,} palavras")

    print("\nüìö Detalhes por Cap√≠tulo:")
    print("-" * 40)

    for chapter in chapter_stats:
        print(
            f"{chapter['status']:<15} {chapter['name']:<25} {chapter['words']:>6,} palavras"
        )

    # Status por categoria
    finalizados = len([c for c in chapter_stats if "Finalizado" in c["status"]])
    em_ia = len([c for c in chapter_stats if "Em revis√£o IA" in c["status"]])
    rascunhos = len([c for c in chapter_stats if "Rascunho" in c["status"]])

    print(f"\nüìà Progresso:")
    print("-" * 40)
    if finalizados > 0:
        print(f"‚úÖ Finalizados: {finalizados}")
    if em_ia > 0:
        print(f"ü§ñ Em revis√£o IA: {em_ia}")
    if rascunhos > 0:
        print(f"üìù Rascunhos: {rascunhos}")


def compile_cmd(args):
    # Busca pela raiz do projeto
    project_root = find_project_root()
    if project_root is None:
        print("‚ùå Erro: Projeto BDL n√£o encontrado. Execute 'bdl init' primeiro.")
        sys.exit(1)

    config = get_project_config(project_root)
    if config is None:
        print("‚ùå Erro: N√£o foi poss√≠vel carregar BDL.yaml.")
        sys.exit(1)

    # Busca cap√≠tulos finalizados primeiro, depois outros
    chapter_paths = [
        project_root / "capitulos" / "finalizados",
        project_root / "capitulos" / "ia",
        project_root / "capitulos",
    ]

    chapters = []
    for cap_dir in chapter_paths:
        if cap_dir.exists():
            for f in sorted(cap_dir.glob("*.md")):
                if "capitulo" in f.name.lower() or f.name.lower().startswith("cap"):
                    chapters.append(f)

    if not chapters:
        print("‚ùå Erro: n√£o h√° cap√≠tulos para compilar.")
        print("   Dica: Adicione arquivos .md em capitulos/finalizados/ ou capitulos/")
        sys.exit(1)

    # Determina formatos solicitados
    formatos = []
    if args.pdf:
        formatos.append("pdf")
    if args.epub:
        formatos.append("epub")
    if args.html:
        formatos.append("html")
    if not formatos:
        formatos = ["pdf"]  # PDF como padr√£o

    # Valida depend√™ncias
    deps = validate_dependencies()
    missing_deps = []

    if "pdf" in formatos and not deps["latex"]:
        missing_deps.append(
            "LaTeX (para PDF) - instale: apt-get install texlive-latex-base"
        )
    if ("epub" in formatos or "html" in formatos) and not deps["pandoc"]:
        missing_deps.append("Pandoc (para EPUB/HTML) - instale: apt-get install pandoc")

    if missing_deps:
        print("‚ùå Depend√™ncias faltando:")
        for dep in missing_deps:
            print(f"   ‚Ä¢ {dep}")
        print("\nüí° Dica: Instale as depend√™ncias e tente novamente.")
        sys.exit(1)

    # Cria diret√≥rio de sa√≠da
    output_dir = project_root / "output"
    output_dir.mkdir(exist_ok=True)

    # Prepara t√≠tulo do livro
    title = config.get("title", "Livro")
    safe_title = re.sub(r"[^\w\s-]", "", title).strip().replace(" ", "_")
    if not safe_title:
        safe_title = "livro"

    print("üìö Compilando manuscrito...")
    print(f"   üìñ T√≠tulo: {title}")
    print(f"   üìÑ Cap√≠tulos encontrados: {len(chapters)}")
    print(f"   üìÅ Sa√≠da: {output_dir}")

    # Simula compila√ß√£o (substitua por implementa√ß√£o real)
    success_files = []
    for fmt in formatos:
        output_file = output_dir / f"{safe_title}.{fmt}"

        # Por enquanto, cria arquivo vazio (implementar compila√ß√£o real depois)
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(f"# {title}\n\n")
            f.write(f"Compilado em: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            for i, chapter in enumerate(chapters, 1):
                f.write(f"## Cap√≠tulo {i}: {chapter.stem}\n\n")
                try:
                    content = chapter.read_text(encoding="utf-8")
                    f.write(content)
                    f.write("\n\n")
                except Exception as e:
                    f.write(f"[Erro ao ler cap√≠tulo: {e}]\n\n")

        success_files.append(output_file.name)

    print("‚úÖ Compila√ß√£o conclu√≠da!")
    print(f"   üì¶ Arquivos gerados: {', '.join(success_files)}")
    print(f"   üìÅ Localiza√ß√£o: {output_dir}")

    # Exibe estat√≠sticas finais
    total_words = sum(count_words_in_file(ch) for ch in chapters)
    print(f"   üìä Total de palavras: {total_words:,}")


def check_cmd(args):
    """Verifica status do projeto e depend√™ncias"""
    print("üîç Verifica√ß√£o do Ambiente BDL")
    print("=" * 40)

    # Verifica projeto
    project_root = find_project_root()
    if project_root:
        print(f"‚úÖ Projeto encontrado: {project_root}")
        config = get_project_config(project_root)
        if config:
            print(f"üìñ T√≠tulo: {config.get('title', 'N√£o definido')}")
            print(f"‚úçÔ∏è  Autor: {config.get('author', 'N√£o definido')}")
        else:
            print("‚ö†Ô∏è  Aviso: BDL.yaml n√£o p√¥de ser carregado")
    else:
        print("‚ùå Nenhum projeto BDL encontrado no diret√≥rio atual ou pais")

    print(f"\nüîß Depend√™ncias Externas:")
    print("-" * 40)

    deps = validate_dependencies()

    if deps["latex"]:
        print("‚úÖ LaTeX dispon√≠vel (para compila√ß√£o PDF)")
    else:
        print("‚ùå LaTeX n√£o encontrado")
        print("   üí° Instale: apt-get install texlive-latex-base")

    if deps["pandoc"]:
        print("‚úÖ Pandoc dispon√≠vel (para EPUB/HTML)")
    else:
        print("‚ùå Pandoc n√£o encontrado")
        print("   üí° Instale: apt-get install pandoc")

    print(f"\nüìä Resumo:")
    print("-" * 40)
    ready_formats = []
    if project_root:
        ready_formats.append("Estrutura de projeto")
    if deps["latex"]:
        ready_formats.append("PDF")
    if deps["pandoc"]:
        ready_formats.append("EPUB/HTML")

    if ready_formats:
        print(f"‚úÖ Pronto para: {', '.join(ready_formats)}")
    else:
        print("‚ùå Configure um projeto BDL e instale depend√™ncias para come√ßar")


def agent_setup_cmd(args):
    """Configura sistema de agentes no projeto atual"""
    project_root = find_project_root()
    if project_root is None:
        print("‚ùå Erro: Projeto BDL n√£o encontrado. Execute 'bdl init' primeiro.")
        sys.exit(1)

    print("ü§ñ Configurando Sistema de Agentes BDL")
    print("=" * 40)

    # Verifica se j√° existe sistema de agentes
    prompts_dir = project_root / ".github" / "prompts"
    if prompts_dir.exists() and any(prompts_dir.glob("*.md")):
        print("‚úÖ Sistema de agentes j√° configurado!")
        print(f"   üìÅ Localiza√ß√£o: {prompts_dir}")

        # Lista agentes existentes
        agents = list(prompts_dir.glob("*.md"))
        if agents:
            print(f"   ü§ñ Agentes dispon√≠veis: {len(agents)}")
            for agent in agents:
                print(f"      ‚Ä¢ {agent.stem}")
    else:
        print("‚ö†Ô∏è  Sistema de agentes n√£o encontrado.")
        print("üí° Para usar agentes BDL:")
        print("   1. Copie os prompts do BDL-project para .github/prompts/")
        print("   2. Personalize constitution.md com suas diretrizes")
        print("   3. Use 'bdl agent status' para verificar configura√ß√£o")

    # Verifica estrutura de diret√≥rios para agentes
    required_dirs = [
        "capitulos/rascunhos",
        "capitulos/ia",
        "capitulos/finalizados",
        "lore",
        "docs",
    ]
    missing_dirs = []

    for dir_name in required_dirs:
        dir_path = project_root / dir_name
        if not dir_path.exists():
            missing_dirs.append(dir_name)

    if missing_dirs:
        print(f"\nüìÅ Diret√≥rios recomendados faltando:")
        for missing in missing_dirs:
            print(f"   ‚Ä¢ {missing}/")

        print(f"\nüí° Criar diret√≥rios? (s/n): ", end="")
        response = input().strip().lower()
        if response in ["s", "sim", "y", "yes"]:
            for missing in missing_dirs:
                dir_path = project_root / missing
                dir_path.mkdir(parents=True, exist_ok=True)
                print(f"   ‚úÖ Criado: {missing}/")


def agent_status_cmd(args):
    """Mostra status do workflow de agentes"""
    project_root = find_project_root()
    if project_root is None:
        print("‚ùå Erro: Projeto BDL n√£o encontrado. Execute 'bdl init' primeiro.")
        sys.exit(1)

    print("ü§ñ Status do Sistema de Agentes")
    print("=" * 40)

    config = get_project_config(project_root)
    if config:
        print(f"üìñ Projeto: {config.get('title', 'Sem t√≠tulo')}")

    # Verifica agentes dispon√≠veis
    prompts_dir = project_root / ".github" / "prompts"
    if not prompts_dir.exists():
        print("‚ùå Sistema de agentes n√£o configurado")
        print("   üí° Execute: bdl agent setup")
        return

    agents = list(prompts_dir.glob("*.md"))
    if not agents:
        print("‚ùå Nenhum agente encontrado")
        print("   üí° Copie os prompts do BDL-project para .github/prompts/")
        return

    print(f"‚úÖ Agentes configurados: {len(agents)}")

    # Categoriza agentes por tipo
    agent_categories = {
        "Core": ["escritor", "editor", "critico", "arquivista"],
        "Governance": ["guardiao_estilo", "guardiao_coesao"],
        "Setup": ["construtor"],
        "Other": [],
    }

    found_agents = {}
    for agent in agents:
        agent_name = agent.stem.replace(".prompt", "")

        # Encontra categoria
        category = "Other"
        for cat, agent_list in agent_categories.items():
            if any(a in agent_name.lower() for a in agent_list):
                category = cat
                break

        if category not in found_agents:
            found_agents[category] = []
        found_agents[category].append(agent_name)

    # Exibe agentes por categoria
    for category, agent_list in found_agents.items():
        if agent_list:
            print(f"\nüè∑Ô∏è  {category}:")
            for agent in sorted(agent_list):
                print(f"   ‚Ä¢ {agent}")

    # Verifica estrutura de workflow
    workflow_dirs = {
        "capitulos/rascunhos": "Rascunhos humanos",
        "capitulos/ia": "Vers√µes IA",
        "capitulos/finalizados": "Cap√≠tulos aprovados",
        "lore": "Base de conhecimento",
        "docs": "Documenta√ß√£o",
    }

    print(f"\nüìÅ Estrutura de Workflow:")
    for dir_name, description in workflow_dirs.items():
        dir_path = project_root / dir_name
        if dir_path.exists():
            file_count = len(list(dir_path.glob("*")))
            print(f"   ‚úÖ {dir_name:<20} ({file_count} arquivos)")
        else:
            print(f"   ‚ùå {dir_name:<20} (n√£o existe)")

    # Verifica arquivos de configura√ß√£o importantes
    config_files = {
        "docs/constitution.md": "Diretrizes de estilo",
        "docs/roadmap.md": "Planejamento do projeto",
    }

    print(f"\n‚öôÔ∏è  Configura√ß√£o:")
    for file_path, description in config_files.items():
        file_full_path = project_root / file_path
        if file_full_path.exists():
            print(f"   ‚úÖ {description}")
        else:
            print(f"   ‚ö†Ô∏è  {description} (recomendado: {file_path})")


def main():
    parser = argparse.ArgumentParser(
        description="BDL Workflow CLI - Ferramenta de linha de comando para Book Development Lifecycle",
        epilog="Para mais informa√ß√µes, visite: https://github.com/seu-usuario/bdl-workflow",
    )
    subparsers = parser.add_subparsers(dest="command", help="Comandos dispon√≠veis")

    # Comando init
    parser_init = subparsers.add_parser(
        "init",
        help="Inicializa um novo projeto BDL",
        description="Cria a estrutura inicial de um projeto de livro com BDL",
    )
    parser_init.add_argument("nome", help="Nome do diret√≥rio do projeto")
    parser_init.add_argument("--title", help="T√≠tulo do livro")
    parser_init.add_argument("--author", help="Autor do livro")
    parser_init.set_defaults(func=init_cmd)

    # Comando stats
    parser_stats = subparsers.add_parser(
        "stats",
        help="Mostra estat√≠sticas do livro",
        description="Analisa cap√≠tulos e exibe estat√≠sticas de progresso",
    )
    parser_stats.set_defaults(func=stats_cmd)

    # Comando compile
    parser_compile = subparsers.add_parser(
        "compile",
        help="Compila o livro em formatos finais",
        description="Gera manuscrito final em PDF, EPUB ou HTML",
    )
    parser_compile.add_argument(
        "--pdf", action="store_true", help="Gerar PDF (requer LaTeX)"
    )
    parser_compile.add_argument(
        "--epub", action="store_true", help="Gerar ePub (requer Pandoc)"
    )
    parser_compile.add_argument(
        "--html", action="store_true", help="Gerar HTML (requer Pandoc)"
    )
    parser_compile.set_defaults(func=compile_cmd)

    # Comando check
    parser_check = subparsers.add_parser(
        "check",
        help="Verifica status do projeto e depend√™ncias",
        description="Diagn√≥stica ambiente e mostra o que est√° pronto para uso",
    )
    parser_check.set_defaults(func=check_cmd)

    # Comando agent (integra√ß√£o com sistema de agentes)
    parser_agent = subparsers.add_parser(
        "agent",
        help="Interface com sistema de agentes BDL",
        description="Comandos para integra√ß√£o com agentes de IA para escrita",
    )
    agent_subparsers = parser_agent.add_subparsers(
        dest="agent_command", help="Comandos de agentes"
    )

    # bdl agent setup
    parser_agent_setup = agent_subparsers.add_parser(
        "setup", help="Configura sistema de agentes no projeto atual"
    )
    parser_agent_setup.set_defaults(func=agent_setup_cmd)

    # bdl agent status
    parser_agent_status = agent_subparsers.add_parser(
        "status", help="Mostra status do workflow de agentes"
    )
    parser_agent_status.set_defaults(func=agent_status_cmd)

    args = parser.parse_args()
    if hasattr(args, "func"):
        try:
            args.func(args)
        except KeyboardInterrupt:
            print("\n\n‚ö†Ô∏è  Opera√ß√£o interrompida pelo usu√°rio.")
            sys.exit(1)
        except Exception as e:
            print(f"\n‚ùå Erro inesperado: {e}")
            print(
                "üí° Se o problema persistir, reporte em: https://github.com/seu-usuario/bdl-workflow/issues"
            )
            sys.exit(1)
    else:
        parser.print_help()
